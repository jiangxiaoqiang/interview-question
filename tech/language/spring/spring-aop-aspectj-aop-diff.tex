
\documentclass[../../../interview-questions.tex]{subfiles}

\begin{document}

\subsection{Spring AOP 和 AspectJ AOP 有什么区别}

Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。
Spring AOP 已经集成了 AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ  相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，
如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。


ASM ：一个轻量级的字节码操作框架，直接涉及到jvm底层操作和指令，使用难度较大。

CGLIB：属于动态织入（字节码加载之后）技术，基于ASM实现，性能高。同时，CGLIB突破了Java动态代理基于接口的限制，采用子类继承的方式。

JAVAssist：属于动态织入技术，操作简单，接口强大，性能较ASM差。

ASPECTJ：静态织入（字节码加载之前）框架，常用于AOP编程框架。

\paragraph{Capabilities and Goals}

简而言之，Spring AOP和AspectJ有不同的目标。
Spring AOP旨在通过Spring IoC提供一个简单的AOP实现，以解决编码人员面临的最常出现的问题。这并不是完整的AOP解决方案，它只能用于Spring容器管理的beans。
另一方面，AspectJ是最原始的AOP实现技术，提供了完整的AOP解决方案。AspectJ更为健壮，相对于Spring AOP也显得更为复杂。值得注意的是，AspectJ能够被应用于所有的领域对象。

\paragraph{Weaving}

AspectJ and Spring AOP使用了不同的织入方式，这影响了他们在性能和易用性方面的行为。
AspectJ使用了三种不同类型的织入：

\begin{enumerate}
    \item {编译时织入：AspectJ编译器同时加载我们切面的源代码和我们的应用程序，并生成一个织入后的类文件作为输出。}
    \item {编译后织入：这就是所熟悉的二进制织入。它被用来编织现有的类文件和JAR文件与我们的切面。}
    \item {加载时织入：这和之前的二进制编织完全一样，所不同的是织入会被延后，直到类加载器将类加载到JVM。}
\end{enumerate}

更多关于AspectJ的信息，请见head on over to this article。AspectJ使用的是编译期和类加载时进行织入，Spring AOP利用的是运行时织入。运行时织入，在使用目标对象的代理执行应用程序时，编译这些切面（使用JDK动态代理或者CGLIB代理）。

https://juejin.cn/post/6844903555531276296


\end{document}





