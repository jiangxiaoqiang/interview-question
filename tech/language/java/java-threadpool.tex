\documentclass[../../../interview-questions.tex]{subfiles}

\begin{document}

\subsection{Java线程池}

\paragraph{Java线程池原理}

J.U.C提供的线程池：ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务。了解并合理使用线程池，是一个开发人员必修的基本功。线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用\footnote{参见：\url{https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html}}。JUC是java.util.concurrent包的简称，在Java5.0添加，目的就是为了更好的支持高并发任务。

待补充。

\paragraph{JVM线程池任务调度(线程池任务添加流程)}

任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。

首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：

首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。
如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。
如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。
如果workerCount >= corePoolSize \&\& workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。
如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。

\paragraph{线程池主要组件}

一个线程池包括以下四个基本组成部分：

\begin{enumerate}
    \item {线程池管理器（ThreadPoolManager）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；}
    \item {工作线程（WorkThread）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；}
    \item {任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；}
    \item {任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。}
\end{enumerate}


\paragraph{创建一个线程池需要输入几个参数}

\textbf{corePoolSize（线程池的基本大小）}：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。

\textbf{maximumPoolSize（线程池最大大小）}：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。

\textbf{runnableTaskQueue（任务队列）}：用于保存等待执行的任务的阻塞队列。
ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助。

\textbf{RejectedExecutionHandler（拒绝策略,饱和策略）}：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。n  AbortPolicy：直接抛出异常。

\textbf{keepAliveTime（线程活动保持时间，线程池的​​工作线程空闲后​​​，​​保持存活的时间​​​）}：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。

\textbf{TimeUnit（线程活动保持时间的单位）}：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。

\paragraph{线程池5个状态}

线程池的5种状态：Running、ShutDown、Stop、Tidying、Terminated。

\textbf{Running}(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。
(2) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！

\begin{figure}[htbp]
	\centering
	\includegraphics[scale=0.15]{threadpollstatus.jpg}
	\caption{线程池状态}
	\label{fig:threadpollstatus}
\end{figure}


\paragraph{线程池如何实现线程复用}

线程池可以把线程和任务进行解耦，线程归线程，任务归任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制。在线程池中，同一个线程可以从 BlockingQueue 中不断提取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中，不停地检查是否还有任务等待被执行，如果有则直接去执行这个任务，也就是调用任务的 run 方法，把 run 方法当作和普通方法一样的地位去调用，相当于把每个任务的 run() 方法串联了起来，所以线程数量并不增加。实现线程复用的逻辑在ThreadPoolExecutor类的runWorker方法中。这个 while 循环有个 getTask 方法，getTask 的主要作用是阻塞从队列中拿任务出来，如果队列中有任务，那么就可以拿出来执行，如果队列中没有任务，这个线程会一直阻塞到有任务为止（或者超时阻塞）。

\begin{lstlisting}[language=Java]
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    while (task != null || (task = getTask()) != null) {
    }
}
\end{lstlisting}

使用队列的 poll 或 take 方法从队列中拿数据，根据队列的特性，队列中有任务可以返回，队列中无任务会阻塞。注意任务阻塞时不消耗CPU资源的\footnote{参见：\url{https://stackoverflow.com/questions/5895895/does-java-blocked-threads-take-up-more-cpu-resources}}。

\begin{lstlisting}[language=Java]
Runnable r = timed ?
    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
    workQueue.take();
\end{lstlisting}
    

线程池的线程复用就是通过取 Worker 的 firstTask 或者通过 getTask 方法从 workQueue 中不停地取任务，并直接调用 Runnable 的 run 方法来执行任务，这样就保证了每个线程都始终在一个循环中，反复获取任务，然后执行任务，从而实现了线程的复用。


\end{document}