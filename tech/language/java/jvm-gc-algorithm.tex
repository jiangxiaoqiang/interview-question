\documentclass[../../../interview-questions.tex]{subfiles}

\begin{document}

\subsection{JVM垃圾回收算法}

\begin{enumerate}
    \item{标记-清除算法 (Mark-Sweep)。}根据名称就可以理解改算法分为两个阶段：首先标记出所有需要被回收的对象，然后对标记的对象进行统一清除，清空对象所占用的内存区域。标记-清除算法的两个缺点：

    第一个：是执行效率不可控，试想一下如果堆中大部分的对象都可回收的，收集器要执行大量的标记、收集操作。
    
    第二个：产生了许多内存碎片，通过回收后的内存状态图可以知道，被回收后的区域内存并不是连续的，当有大对象要分配而找不到满足大小的空间时，要触发下一次垃圾收集。
    \item{标记-复制算法 (Mark-Copying)。}针对标记-清除算法执行效率与内存碎片的缺点，计算机科学家又提出了一种“半复制区域”的算法。

    标记-复制算法将内存分为大小相同的两个区域，运行区域，预留区域，所有创建的新对象都分配到运行区域，当运行区域内存不够时，将运作区域中存活对象全部复制到预留区域，然后再清空整个运行区域内存，这时两块区域的角色也发生了变化，每次存活的对象就像皮球一下在运行区域与预留区域踢来踢出，而垃圾对象会随着整个区域内存的清空而释放掉。标记-复制算法在大量垃圾对象的情况下，只需复制少量的存活对象，并且不会产生内存碎片问题，新内存的分配只需要移动堆顶指针顺序分配即可，很好的兼顾了效率与内存碎片的问题。JVM堆的年轻代Survivor0区和Survivor1区就是采用的这种策略。但是标注-复制算法也存在缺点，预留一半的内存区域未免有些浪费了，并且如果内存中大量的是存活状态，只有少量的垃圾对象，收集器要执行更多次的复制操作才能释放少量的内存空间，得不偿失。
    \item{标记-整理算法 (Mark-Compact)。}标记-复制算法要浪费一半内存空间，且在大多数状态为存活状态时使用效率会很低，针对这一情况计算机科学家又提出了一种新的算法“标记-整理算法”，标记整理算法的标记阶段与其他算法一样，但是在整理阶段，算法将存活的对象向内存空间的一端移动，然后将存活对象边界以外的空间全部清空。标记整理算法解决了内存碎片问题，也不存在空间的浪费问题，看上去挺美好的。但是，当内存中存活对象多，并且都是一些微小对象，而垃圾对象少时，要移动大量的存活对象才能换取少量的内存空间。
    \item{分代收集算法 (Generational Collection)。}分代算法是以上几种算法的综合引用。它先根据对象的存活周期将内存分为几块：新生代(Young Generation)和老年代(Old Generation)。在JDK8以前还有个永久代(Permanent Generation)，不过JDK8以后永久代就被元空间(Metaspace)取代了。几乎所有新生成的对象首先都是放在年轻代的，也有少部分大对象（如大数组）是直接分配老年代的。
    新生代采用复制算法，但不再是将内存一分为二，而是划分为Eden区、Survivor 0区、Survivor 1区，比例（8：1：1），这个也是可以调整的。
    刚生成的对象一般是在Eden区，当Eden区满了后，就进行一次新生代GC。将存活的对象复制到Survivor 0区，此时Survivor 1区是空白的。接着将新生成的对象放到Eden区，直到Survivor 0区也满了，则将Eden区和Survivor 0区的存活对象复制到Survivor 1区，清理Eden和Survivor 0，此时，Survivor 0区变成空白的，Survivor 0和Survivor 1 区功能互换（即eden区满了则GC后放到Survivor 1区）。
    每当对象熬过一次新生代GC，则年龄+1，直到15（默认的，可修改）后，将其复制到老年代。
    老年代中存放一些生命周期比较长的对象，或者是一些大对象。老年代GC的频率比较低，标记存活率高。老年代一般采用标记-整理算法。
\end{enumerate}


\end{document}

