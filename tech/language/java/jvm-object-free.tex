\documentclass[../../../interview-questions.tex]{subfiles}

\begin{document}

\subsection{在JVM中如何判断一个对象的生死状态？}

\paragraph{引用计数器算法（Reference Counting)}

引用计算器判断对象是否存活的算法是这样的：给每一个对象设置一个引用计数器，每当有一个地方引用这个对象的时候，计数器就加1，与之相反，每当引用失效的时候就减1。

优点：实现简单、性能高。

缺点：增减处理频繁消耗CPU计算、计数器占用很多位浪费空间、最重要的缺点是无法解决循环引用的问题。

\paragraph{可达性分析算法（Reachability Analysis）)}

在主流的语言的主流实现中，比如Java、C\#、甚至是古老的Lisp都是使用的可达性分析算法来判断对象是否存活的。通过一系列称之为 “GC Roots” 的根对象作为起点，从这些对象开始向下搜索遍历，所有搜索过的路径称之为引用链(Reference Chain)，当一个对象到 GC Roots 没有任何一个引用链相连(对象不可达)时，证明该对象已不再被引用(失效)，此时该对象将被 GC 回收\footnote{参见：\url{https://www.wikiwand.com/en/Reference_counting}}。

3、对象生死与引用的关系

在JDK1.2之前，引用的定义很传统：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一块引用。这样的定义很纯粹，但是也很狭隘，这种情况下一个对象要么被引用，要么没引用，对于介于两者之间的对象显得无能为力。JDK1.2之后对引用进行了扩充，将引用分为：

强引用（Strong Reference）

软引用（Soft Reference）

弱引用（Weak Reference）

虚引用（Phantom Reference）

在Java中，可作为GC Roots对象的列表：

1.虚拟机栈（栈帧中的本地变量表）中引用的对象\footnote{\url{https://blog.csdn.net/u010798968/article/details/72835255}}；

2.方法区中的类静态属性引用的对象；

3.方法区中常量引用的对象；

4.本地方法栈中JNI（即一般说的Native方法）中引用的对象

GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。


\paragraph{死亡标记与拯救(对象死亡标记)}

在可达性算法中不可达的对象，并不是“非死不可”的，要真正宣告一个对象死亡，至少要经历两次标记的过程。
如果对象在进行可达性分析之后，没有与GC Roots相连接的引用链，它会被第一次标记，并进行筛选，筛选的条件是此对象是否有必要执行finalize()方法。

\end{document}

