\documentclass[../../../interview-questions.tex]{subfiles}

\begin{document}

\subsection{在JVM中如何判断一个对象的生死状态？}

\paragraph{引用计数器算法（Reference Counting)}

引用计算器判断对象是否存活的算法是这样的：给每一个对象设置一个引用计数器，每当有一个地方引用这个对象的时候，计数器就加1，与之相反，每当引用失效的时候就减1。

优点：实现简单、性能高。

缺点：增减处理频繁消耗CPU计算、计数器占用很多位浪费空间、最重要的缺点是无法解决循环引用的问题。

在Java虚拟机中并不使用引用计数法来管理内存，而是使用其他算法，如可达性分析算法。可达性分析算法能够解决循环引用的问题，并且在实际应用中已经证明是一种有效的内存管理技术。引用计数器算法主要用于一些特殊场景，例如：嵌入式系统中：因为嵌入式系统的资源受限，所以需要使用轻量级的垃圾回收算法，引用计数器算法由于实现简单、占用空间小，能够在这种场景下发挥优势。弱实时性系统中：引用计数器算法的特点是垃圾回收过程可以分散到程序执行过程中，因此不需要在程序运行时暂停处理垃圾回收，这种特性在弱实时性系统中非常适用。单线程程序中：因为单线程程序不需要考虑多线程并发的问题，引用计数器算法可以在这种场景下更好地发挥其优势。

\paragraph{可达性分析算法（Reachability Analysis）}

在主流的语言实现中，比如Java、C\#、甚至是古老的Lisp都是使用的可达性分析算法来判断对象是否存活的。通过一系列称之为 “GC Roots” 的根对象作为起点，从这些对象开始向下搜索遍历，所有搜索过的路径称之为引用链(Reference Chain)，当一个对象到 GC Roots 没有任何一个引用链相连(对象不可达)时，证明该对象已不再被引用(失效)，此时该对象将被 GC 回收\footnote{参见：\url{https://www.wikiwand.com/en/Reference_counting}}。

3、对象生死与引用的关系

在JDK1.2之前，引用的定义很传统：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一块引用。这样的定义很纯粹，但是也很狭隘，这种情况下一个对象要么被引用，要么没引用，对于介于两者之间的对象显得无能为力。JDK1.2之后对引用进行了扩充，将引用分为：

强引用（Strong Reference）

软引用（Soft Reference）

弱引用（Weak Reference）

虚引用（Phantom Reference）

\paragraph{死亡标记与拯救(对象死亡标记)}

在可达性算法中不可达的对象，并不是“非死不可”的，要真正宣告一个对象死亡，至少要经历两次标记的过程。
如果对象在进行可达性分析之后，没有与GC Roots相连接的引用链，它会被第一次标记，并进行筛选，筛选的条件是此对象是否有必要执行finalize()方法。

\end{document}

