\documentclass[../../../interview-questions.tex]{subfiles}

\begin{document}

\subsection{\color{red}{Java内存模型(Java Memory Model)}}

内存模型的出现是为了解决共享变量读写的原子性(Atomicity)、可见性(Visibility)和有序性(Ordering)问题\footnote{\url{https://gee.cs.oswego.edu/dl/cpj/jmm.html}}。Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如原子性、可见性和有序性的问题。JMM(Java Memory Model)就是为了解决这些问题而出现的，这个模型建立了一些规范，来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果,以保证在多核CPU多线程编程环境下，对共享变量读写的原子性、可见性和有序性。为了既保证CPU的高效执行，又保证共享内存读写的正确性（原子性、可见性和有序性），人们定义了内存模型。内存模型是一个规范，这个规范能保证共享内存读写的正确性。上面提到内存模型的出现是为了解决共享变量读写的原子性、可见性和有序性问题，再简单点说 JMM就是一个为了解决多核CPU多线程编程环境下对共享变量访问存在原子性、可见性和有序性问题的规范。Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：

\begin{itemize}
    \item {线程之间的共享变量存储在主内存（Main Memory）中}
    \item {每个线程都有一个私有的本地内存（Local Memory），本地内存是JMM的一个抽象概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。本地内存中存储了该线程以读/写共享变量的拷贝副本。}
    \item {从更低的层次来说，主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。}
    \item {Java内存模型中的线程的工作内存（working memory）是cpu的寄存器和高速缓存的抽象描述。而JVM的静态内存储模型（JVM内存模型）只是一种对内存的物理划分而已，它只局限在内存，而且只局限在JVM的内存。}
\end{itemize}

它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。

Java内存模型规定了所有的变量（此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数）都存储在主内存中（此处的主内存与介绍物理硬件时提到的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的一部分），每条线程还有自己的工作内存（可与前面讲的处理器高速缓存类比），线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。也就是说Java线程之间的通信由Java内存模型控制， JMM决定一个线程对共享变量的写入何时对另一个线程可见。

https://www.cnblogs.com/54chensongxia/p/12022648.html



\end{document}