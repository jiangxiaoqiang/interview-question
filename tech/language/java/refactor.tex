\documentclass[../../../interview-questions.tex]{subfiles}

\begin{document}

\subsection{反射的实现原理}

Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。Class对象是在加载类时由JVM构造的，JVM为每个类管理一个独一无二的Class对象，这份Class对象里维护着该类的所有Method，Field，Constructor的cache，这份cache也可以被称作根对象。我理解的Java反射的原理就是获取Class对象然后使用java.lang.reflect里提供的方法操作Class对象，Class与java.lang.reflect构成了java的反射技术。反射在Java中可以直接调用，不过最终调用的仍是native方法。Class.forName可以通过包名寻找Class对象，比如Class.forName("java.lang.String")。在JDK的源码实现中，可以发现最终调用的是native方法forName0()，它在JVM中调用的实际是findClassFromClassLoader()。

\begin{lstlisting}[language=Java]
private static native Class<?> forName0(String name, boolean initialize,
                                            ClassLoader loader,
                                            Class<?> caller)
        throws ClassNotFoundException;
\end{lstlisting}

如注释所述，实际的MethodAccessor实现有两个版本，一个是Java实现的，另一个是native code实现的。Java实现的版本在初始化时需要较多时间，但长久来说性能较好；native版本正好相反，启动时相对较快，但运行时间长了之后速度就比不过Java版了。这是HotSpot的优化方式带来的性能特性，同时也是许多虚拟机的共同点：跨越native边界会对优化有阻碍作用，它就像个黑箱一样让虚拟机难以分析也将其内联，于是运行时间长了之后反而是托管版本的代码更快些。
为了权衡两个版本的性能，Sun的JDK使用了“inflation”的技巧：让Java方法在被反射调用时，开头若干次使用native版，等反射调用次数超过阈值时则生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码，以后对该Java方法的反射调用就会使用Java版\footnote{参见：\url{https://www.iteye.com/blog/rednaxelafx-548536}}。具体Java版和Native版本的实现分析参见这里\footnote{\url{https://www.iteye.com/blog/rednaxelafx-548536}}。网上许多分析文章写到这里就到此为止了。尝试调试Hotspot的原始码，看看反射到底是怎么实现的。首先下载JDK11 Hotspot的源代码：

\begin{lstlisting}[language=Bash]
wget -c https://hg.openjdk.java.net/jdk-updates/jdk11u/archive/tip.tar.gz    
\end{lstlisting}

\end{document}