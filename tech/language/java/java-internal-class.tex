\subsection{内部类}

一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建其的外围类的对象。所以你可以认为内部类提供了某种进入其外围类的窗口。如果没有内部类提供的可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。 从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了"多重继承"。内部类可以分为：静态内部类（嵌套类）和非静态内部类。非静态内部类又可以分为：成员内部类、方法内部类、匿名内部类。成员内部类：

\begin{lstlisting}[language=Java]
/**
 * @author jiangtingqiang@gmail.com
 * @create 2019-05-11-19:16
 */
public class Outer {
    public class Inner{
        // 实例化方法一
        Outer.Inner innerInstance = new Outer().new Inner();
        // 实例化方法二
        Outer outer = new Outer();
        Outer.Inner getInnerInstance1 = outer.new Inner();
    }
}
\end{lstlisting}


那么内部类实现一个接口与外围类实现一个接口有什么区别呢？答案是：后者不是总能享受到接口所带来的方便。

为什么要使用内部类？最大的原因是：

\begin{enumerate}
\item {内部类方法可以访问该类定义所在作用域中的数据，包括被 private 修饰的私有数据}可是为什么内部类就可以随意访问外部类的成员呢？是如何做到的呢？当外部类的对象创建了一个内部类的对象时，内部类对象必定会秘密捕获一个指向外部类对象的引用，然后访问外部类的成员时，就是用那个引用来选择外围类的成员的。当然这些编辑器已经帮我们处理了。 另外注意内部类只是一种编译器现象，与虚拟机无关。编译器会将内部类编译成 外部类名\$内部类名 的常规文件，虚拟机对此一无所知
\item {内部类可以对同一包中的其他类隐藏起来}
\item {内部类可以弥补java单继承的缺陷}
\item {当我们想要定义一个回调函数却不想写大量代码的时候我们可以选择使用匿名内部类来实现}
\end{enumerate}
